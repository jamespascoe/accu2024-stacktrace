<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Advanced Usage of the C++23 Stacktrace Library</title>

    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico?">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/league.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/github.css" id="highlight-theme">

  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <section id="Title-Slide"
                 data-state="hideControls"
                 data-menu-title="Title Slide"
                 data-background-image="media/title-slide.png"
                 data-background-size="contain">
        </section>

        <section data-menu-title="Overview">
          <h2>Advanced Usage of the C++23 Stacktrace Library</h2>
            <p>
            <h4>(Stacktraces and How to Use Them)</h4>
            <small>
              Jim (James) Pascoe<br>
              <a href="http://www.james-pascoe.com">http://www.james-pascoe.com</a><br>
              <a href="mailto:james@james-pascoe.com">james@james-pascoe.com</a><p>

              <a href="http://jamespascoe.github.io/accu2024-stacktrace">http://jamespascoe.github.io/accu2024-stacktrace</a>
              <a href="https://github.com/jamespascoe/accu2024-example-code">https://github.com/jamespascoe/accu2024-example-code</a>
              <p>
              <font style="color:yellow">ACCU Bristol and Bath Meetup Coordinator</font>
            </small>
          <aside class="notes">
          Hello, good afternoon and welcome - my name is Jim Pascoe and today I am going to talk to you about Stacktraces and
          in particular, stacktraces in C++. I am going to talk mainly about the C++23 Stacktrace library and how you can use
          it in interesting ways, but I am also going to discuss some complementary approaches that you may not be aware of.
          So, there are two goals for my talk, firstly to show how Stacktraces can be used for more than just debugging logical
          errors and secondly, to share some libraries and insights that I have found useful.
          <p>
          Here is my email address and URL (if you want to find out a bit about what I've done in the past) and also, this
          is the link to the online talk, so you can follow along from the comfort of your own browser if you prefer. The
          slides are written using Reveal.js, so you can use the hamburger icon to skip between the slides and select a light
          theme if you prefer.
          <p>
          This is a link to the example code that accompanies the presentation. Along with the C++ is some CMake, so it should be
          straightforward to build the code on most modern platforms,
          </aside>
        </section>

        <section data-menu-title="Stacktraces">
          <h3 style="color:yellow">Stacktraces, tracebacks, call sequences</h3>
          <ul>
            <span class="fragment"><li>Locate problems without a debugger</li></span>
            <span class="fragment"><ul><li>
              assertions,
              <span class="fragment"> exceptions,</span>
              <span class="fragment"> unreachable code</span>
            </li></ul></span>
            <span class="fragment"><li>Introspection</li></span>
            <span class="fragment"><ul><li>object lifetimes e.g. RAII</span></li></ul></span>
            <span class="fragment"><ul><li>insightful with coroutines</span></li></ul></span>
            <span class="fragment"><li>Signal tracing e.g. SEGV</span><span class="fragment"> (but use with caution)</span></li>
          </ul>
          <aside class="notes">
          C++ calls them stacktraces (as does C#), in Python they are tracebacks. But we probably all recognise a stacktrace
          as being a snapshot. A snapshot of a sequence of function calls that have led to some interesting event (typically
          an exception).
          <p>
          The primary use-case for stacktraces is debugging logical errors, for example, tracebacks in Python. In the field, stacktraces
          allow you to locate problems without a debugger. In C++, stacktraces enrich assertions, exceptions and allow us to see the
          call sequence that has led to some piece of unreachable code or undefined state.
          <p>
          And Signal Tracing - what to do when you encounter a segfault. It turns out that you have to be careful when using stacktraces
          in the context of signal handlers, but more on that later.
          </aside>
        </section>

        <section data-menu-title="Approaches">
          <h3 style="color:yellow">Stacktraces in C++</h3>
          <ul>
            <span class="fragment"><li>C++23 gives us standardised stacktraces</li></span>
            <span class="fragment"><ul><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0881r7.html">P0881R7: A Proposal to Add A Stacktrace Library</a></li></ul></span>
            <span class="fragment"><li>Alternatives:</span></li></span>
              <ul>
                <span class="fragment"><li><a href="https://github.com/jeremy-rifkin/cpptrace">cpptrace</a>: C++11, good treatment of signal-safety</li></span>
                <span class="fragment"><li><a href="https://github.com/bombela/backward-cpp">backward-cpp</a>: stack trace pretty printing</li></span>
                <span class="fragment"><li><a href="https://www.boost.org/doc/libs/master/doc/html/stacktrace.html">Boost::Stacktrace</a>: mature, also some signal-safety</li></span>
              </ul>
          </ul>
          <aside class="notes">
          Before C++23, there was no standard way of producing a stacktrace in C++. If you wanted to get the current call stack, you had to use
          a combination of compiler support and external libraries. But now, any compiler that implements C++23 will provide stacktrace support
          as standard (which is a good thing).<click>
          <p>
          This is the paper that was voted into C++23. Its quite readable, its short and it contains some of the motivation behind the design
          decisions, so I would recommend having a look even if its just to know what it contains.
          <p>
          Apart from what's in C++23, there are some alternate approaches. One, that I am particularly excited about is cpptrace. cpptrace supports
          C++11 onwards, all of the major platforms and has some nice features over and above C++23. Plus, cpptrace has some good advice on signal
          safety (which, as it turns out, is quite tricky in the context of stacktracing).
          <p>
          backward-cpp is also nice. backward-cpp is primarily a stacktrace pretty-printer and we will see some examples in a minute of why that
          is important.
          <p>
          Boost::stacktrace which is very mature, its what C++23 stacktrace was based on, also has a good advice in the context of signal safety.
          </aside>
        </section>

        <section data-menu-title="Fibonacci Example">
          <h2><a href="https://github.com/jamespascoe/accu2024-example-code/blob/master/stacktrace.cpp">Fibonacci (with stacktrace)</a></h2>
          <pre class="r-stretch"><code class="c++" data-trim data-line-numbers="|15-25|17-22|17|17-22|27-30|37-38|41-42|44-49|">
#include &ltiostream&gt
#include &ltformat&gt
#include &ltstacktrace&gt

class fib_with_stacktrace {

  std::stacktrace::size_type max_depth = 0;
  std::stacktrace max_trace;

public:

  fib_with_stacktrace() = default;

  // Return the nth number in the fibonaci sequence
  unsigned int fib(unsigned int n)
  {
    auto trace = std::stacktrace::current();
    auto depth = trace.size();
    if (trace.size() &gt max_depth) {
      max_trace = trace;
      max_depth = depth;
    }

    return n &lt 2 ? n : fib(n-1) + fib(n-2);
  }

  std::stacktrace get_max_trace() const
  {
    return max_trace;
  }
};

int main(void)
{
  fib_with_stacktrace fib_wst;

  for (int i=0; i&lt10; ++i)
    std::cout &lt&lt fib_wst.fib(i) &lt&lt ' ';
  std::cout &lt&lt '\n';

  const std::stacktrace& trace = fib_wst.get_max_trace();
  std::cout &lt&lt "Max stack depth: " &lt&lt trace.size() &lt&lt '\n';

  for (const auto& t : trace)
    std::cout &lt&lt
      std::format (
       "{}:{} {}\n",
       t.source_file(), t.source_line(), t.description()
    );
}
          </code></pre>
          <aside class="notes">
          std::stacktrace is an iterable container for stactrace entries, where each entry is a stack frame.
          </aside>
        </section>

        <section>
          <h3 style="color:yellow">Compilation and Linking</h3>
          <ul>
            <span class="fragment"><li>GCC build must be enabled with:</li></span>
            <span class="fragment"><ul><li><a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_macros.html">--enable-libstdcxx-backtrace=yes</a></li></ul></span>
            <span class="fragment"><li>'libstdcxx-backtrace' is the implementation:</li></span>
            <span class="fragment"><ul><li><a href="https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=libstdc%2B%2B-v3/include/std/stacktrace;h=92a69a53d986c5da990594e3f35e724b0a16b501;hb=refs/heads/trunk">
              &ltgcc trunk&gt/libstdc++-v3/include/std/stacktrace</a></li></ul></span>
            <span class="fragment"><ul><li><a href="https://gcc.gnu.org/git/?p=gcc.git;a=tree;f=libbacktrace;h=46da9877b26555ae4448a7eb642e7218043cce0a;hb=refs/heads/trunk">
              &ltgcc trunk&gt/libbacktrace</a></li></ul></span>
            <span class="fragment"><li>Compiler options:</li></span>
            <span class="fragment"><ul><li>-g -lstdc++_libbacktrace</li></ul></span>
         </ul>
         <aside class="notes">
         I am using GCC 13.0. If you use GCC, you need to configure the compiler to build libstdc++-backtrace. I have a feeling that this has been enabled by default,
         so this may not be a requirement in GCC 13.3.
         </aside>
        </section>

        <section>
          <h2>Fibonacci Output</h2>
          <pre><code data-trim data-line-numbers="|1-2|13-15|12|4-11|3|">
0 1 1 2 3 5 8 13 21 34
Max stack depth was: 13
stacktrace.cpp:17 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:38 main
:0 // __libc_start_main (&ltglibc trunk&gt/csu/libc-start.c:129)
:0 _start
:0
          </code></pre>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h3 style="color:yellow">Observations</h3>
          <ul>
            <span class="fragment"><li>Attach information to stack frames via hash support</li></span>
            <span class="fragment"><ul><li><a href="https://en.cppreference.com/w/cpp/utility/stacktrace_entry/hash">std::unordered_map&ltstd::stacktrace_entry, T&gt</a></li></ul></span>
            <span class="fragment"><li>GDB is great for exploring</li></span>
            <span class="fragment"><ul><li>Tip: <a href="https://github.com/cyrus-and/gdb-dashboard">Andrea Cardaci's GDB Dashboard</a></li></ul></span>
            <span class="fragment"><li>Observer for implementation defined native handle</li></span>
            <span class="fragment"><ul><li><a href="https://en.cppreference.com/w/cpp/utility/stacktrace_entry/native_handle">constexpr nh_type native_handle() const noexcept;</a></li></ul></span>
          </ul>
          <aside class="notes">
          </aside>
        </section>

        <section data-menu-title="GDB Dashboard">
          <img class="r-stretch" data-src="media/gdb_dashboard.png" style="background:none; border:none; box-shadow:none;">
        </section>

        <section>
          <h2><a href="https://github.com/jamespascoe/accu2024-example-code/blob/master/coro_http_server.cpp">Coroutine Example</a></h2>
          <pre class="stretch"><code class="c++" style="width:105%" data-trim data-line-numbers="|129-163|88-127|116|117-125|32-86|63-70|68|">
// This is based on the Boost.Beast HTTP coro server example.
// See the following for documentation and details:
//
// https://www.boost.org/doc/libs/1_84_0/libs/beast/doc/html/
// beast/examples.html#beast.examples.servers_advanced

#include &ltboost/asio/dispatch.hpp&gt
#include &ltboost/asio/spawn.hpp&gt
#include &ltboost/asio/strand.hpp&gt
#include &ltboost/beast/core.hpp&gt
#include &ltboost/beast/http.hpp&gt
#include &ltboost/beast/version.hpp&gt
#include &ltboost/config.hpp&gt

#include &ltiostream&gt
#include &ltmemory&gt
#include &ltthread&gt
#include &ltvector&gt
#include &ltstacktrace&gt
#include &ltformat&gt

namespace beast = boost::beast;
namespace http = beast::http;
namespace asio = boost::asio;
using tcp = boost::asio::ip::tcp;

// Report an error
void error(beast::error_code ec, char const* msg)
{
  std::cerr &lt&lt std::format("Error: {} - {}\n", msg, ec.message());
}

void do_session(
    beast::tcp_stream& stream,
    asio::yield_context yield)
{
  beast::flat_buffer buffer;
  beast::error_code ec;

  for(;;)
  {
    // Set a timeout (in case the client stops responding)
    stream.expires_after(std::chrono::seconds(30));

    // Read a request
    http::request&lthttp::string_body&gt req;
    http::async_read(stream, buffer, req, yield[ec]);

    if(ec == http::error::end_of_stream) break;

    if(ec) return error(ec, "read request");

    // Handle the request
    auto handle_request = [&req]() -&gt http::message_generator {
      http::response&lthttp::string_body&gt res{
        http::status::ok, req.version()
      };
      res.set(http::field::server, "Beast");
      res.body() = "Hello ACCU 2024!";
      res.prepare_payload();
      res.keep_alive(req.keep_alive());

      for (const auto& t : std::stacktrace::current()) {
        std::string desc = t.description();
        std::cout &lt&lt
          std::format("{}:{}\n  {}()\n",
            t.source_file(), t.source_line(),
            desc.substr(0, desc.find_first_of("(&lt"))
          );
      }

      return res;
    };

    // Send the response
    beast::async_write(stream, handle_request(), yield[ec]);

    if(ec) return error(ec, "write response");

    // Determine if we should close the connection
    if(!req.keep_alive()) break;
  }

  // Close the connection
  stream.socket().shutdown(tcp::socket::shutdown_send, ec);
}

// Accepts incoming connections and launches the sessions
void do_listen(
    asio::io_context& ioc,
    tcp::endpoint endpoint,
    asio::yield_context yield)
{
  beast::error_code ec;

  // Open the acceptor
  tcp::acceptor acceptor(ioc);
  acceptor.open(endpoint.protocol(), ec);
  if(ec) return error(ec, "open");

  // Allow address reuse
  acceptor.set_option(asio::socket_base::reuse_address(true), ec);
  if(ec) return error(ec, "set_option");

  // Bind to the server address
  acceptor.bind(endpoint, ec);
  if(ec) return error(ec, "bind");

  // Start listening for connections
  acceptor.listen(asio::socket_base::max_listen_connections, ec);
  if(ec) return error(ec, "listen");

  for(;;)
  {
    tcp::socket socket(ioc);
    acceptor.async_accept(socket, yield[ec]);
    if(ec)
      error(ec, "accept");
    else
      boost::asio::spawn(
          acceptor.get_executor(),
          std::bind(
            do_session,
            beast::tcp_stream(std::move(socket)),
            std::placeholders::_1));
  }
}

int main(int argc, char *argv[])
{
  if (argc != 4) {
    std::cerr &lt&lt std::format(
        "Usage: {} &ltip-address&gt &ltport&gt &ltnum_threads&gt\n"
        "E.g.: {} 0.0.0.0 8080 2\n",
        argv[0], argv[0]
        );
    return EXIT_FAILURE;
  }

  auto const address = asio::ip::make_address(argv[1]);
  auto const port = static_cast&ltunsigned short&gt(std::atoi(argv[2]));
  auto const num_threads = std::max&ltint&gt(1, std::atoi(argv[3]));

  asio::io_context ioc{num_threads};

  // Spawn a coroutine
  boost::asio::spawn(ioc,
      std::bind(
        &do_listen,
        std::ref(ioc),
        tcp::endpoint{address, port},
        std::placeholders::_1));

  // Run the IO service with the requested number of threads
  std::vector&ltstd::thread&gt v(num_threads-1);
  for (auto i = num_threads - 1; i; --i)
    v.emplace_back([&ioc]{ ioc.run(); });

  // Use the main thread as well
  ioc.run();

  return EXIT_SUCCESS;
}
          </code></pre>
          <aside class="notes">
          Ok, so lets have a look at a more complex example. This is a web server that is implemented
          using Coroutines. It's based on Boost.Beast, which is an excellent header only library for
          writing networking code. What Boost.Beast gives you is a set of low-level networking primitives,
          including support for HTTP and Websockets. Its based on Boost.Asio and also has some excellent
          examples of networking code written using C++ coroutines.
          <p>
          When spawn is invoked, Boost.Asio uses a strand to dispatch an internal handler that creates a coroutine
          using 'do_listen' as an entry point. <click>do_listen gets invoked within the call to spawn, we do some
          setup and then the coroutine yields back to the dispatcher on the async_accept. At some point in the future,
          we get a TCP connection and the coroutine is resumed on line 117. At that point, we spawn another coroutine
          to 'do the session'. Similar idea, we read some data asynchronously and then prepare a response.
          <p>
          Now, just before we send the response, I am going to print a stacktrace and I am going to do so in a
          particular format. <click> Who can tell me what I am doing on lne 68? Yes, I am removing the template
          arguments and the function's parameters from the output (so, I am just printing the function's name).
          <p>
          Lets look at the output.
          </aside>
        </section>

        <section>
          <h2>Coroutine Output</h2>
          <pre class="r-stretch"><code class="language-plaintext" data-trim data-line-numbers="|2,4,6,8,10,12,14,16,18,20,22|1,3,5,7,9,11,13,15,17,19,21|">
/home/pascoej/accu2024-example-code/coro_http_server.cpp:58
  operator()
/home/pascoej/accu2024-example-code/coro_http_server.cpp:71
  do_session()
/usr/local/include/c++/13.0.1/bits/invoke.h:61
  void std::__invoke_impl()
/usr/local/include/c++/13.0.1/bits/invoke.h:96
  std::__invoke_result()
/usr/local/include/c++/13.0.1/functional:506
  void std::_Bind()
/usr/local/include/c++/13.0.1/functional:591
  void std::_Bind()
/usr/local/include/boost/asio/impl/spawn.hpp:1493
  boost::asio::detail::old_spawn_entry_point()
/usr/local/include/boost/asio/impl/spawn.hpp:1485
  boost::asio::detail::old_spawn_entry_point()
/usr/local/include/boost/asio/impl/spawn.hpp:158
  boost::asio::detail::spawned_coroutine_thread::entry_point()
/usr/local/include/boost/coroutine/detail/pull_coroutine_object.hpp:290
  boost::coroutines::detail::pull_coroutine_object()
/usr/local/include/boost/coroutine/detail/trampoline_pull.hpp:41
  void boost::coroutines::detail::trampoline_pull()
:0
          </code></pre>
          <aside class="notes">
          So, the reason that I formatted the output, is that by default, you will get everything,
          which includes template parameters plus lots of function arguments that also have complex
          template parameters. So, whilst its a good idea to enrich code with stacktraces, just be
          careful that the output may well be quite extensive.
          </aside>
        </section>

        <section>
          <h2 style="color:yellow">Asynchronous Signal Safety</h2>
          <ul>
            <span class="fragment"><li>How do I get a stack trace in a signal handler?</li></span>
            <span class="fragment"><li>Tricky to implement safely</li>
            <span class="fragment"><ul><li>Collect minimal information in the handler</li></ul></span>
            <span class="fragment"><ul><li>Resolve outside (or in another process)</li></ul></span>

            <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/header/stacktrace">std::stacktrace</a> is not (currently) signal safe</li></span>
            <span class="fragment"><ul><li>But could be in the future</li></ul></span>
            <span class="fragment"><li>See: <a href="https://github.com/jeremy-rifkin/cpptrace">cpptrace</a> and 
              <a href="https://www.boost.org/doc/libs/master/doc/html/stacktrace/reference.html#header.boost.stacktrace.safe_dump_to_hpp">Boost::safe_dump_to</a></li>
          </ul>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h2 style="color:yellow">Conclusions</h2>
          <ul>
            <span class="fragment"><li>Stacktraces are useful</li>
              <span class="fragment"><ul><li>Enrichment, </span>
              <span class="fragment">introspection, </span>
              <span class="fragment">object lifetimes</li></ul></span>
            <span class="fragment"><li>Stack depth can be a useful proxy</li>
            <span class="fragment"><ul><li>Inexpensive to store - easy to chart</li></ul>
            <span class="fragment"><li>Use with caution in signal handlers</li></span>
            <span class="fragment"><li>Be mindful of stacktrace output</span><span class="fragment"> (extensive)</span></li>
            <span class="fragment"><li>Debugging starts in the design phase</li></span>
          </ul>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h2 style="color:yellow">Resources</h2>
          <ul>
            <span class="fragment"><li><a href="https://youtu.be/9IcxniCxKlQ?si=GtuMOVHm8wzRvv56">Episode 336: C++ Weekly (Jason Turner)</a></li></span>
            <span class="fragment"><li><a href="https://www.sandordargo.com/blog/2022/09/21/cpp23-stacktrace-library">Sandor Dargo's Blog</a></li></span>
            <span class="fragment"><li><a href="https://www.boost.org/doc/libs/master/doc/html/stacktrace.html">Boost::Stacktrace Documentation</a></li>
            <span class="fragment"><li>Signal safety:</li>
            <span class="fragment"><ul><li><a href="https://www.boost.org/doc/libs/master/doc/html/stacktrace/theoretical_async_signal_safety.html">Theoretical Async Signal Safety (Boost)</a></li></ul>
            <span class="fragment"><ul><li><a href="https://github.com/jeremy-rifkin/cpptrace?tab=readme-ov-file#signal-safe-tracing">Signal-Safe Tracing (cpptrace)</a></li></ul>
            <span class="fragment"><ul><li><a href="https://man7.org/linux/man-pages/man7/signal-safety.7.html">signal-safety (Linux man page)</a></li></ul>
          </ul>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h2>Questions?</h2>
          <p><p>
          <a href="http://www.james-pascoe.com">http://www.james-pascoe.com</a><br>
          <a href="mailto:james@james-pascoe.com">james@james-pascoe.com</a><p>

          <small>
          <a href="http://jamespascoe.github.io/accu2024-stacktrace">http://jamespascoe.github.io/accu2024-stacktrace</a>
          <a href="https://github.com/jamespascoe/accu2024-example-code">https://github.com/jamespascoe/accu2024-example-code</a>
          </small>
          <p>
          <font style="color:yellow">ACCU Bristol and Bath Meetup Coordinator</font>
        </section>

        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/menu/menu.js"></script>
    <script src="plugin/chart/Chart.min.js"></script>
    <script src="plugin/chart/plugin.js"></script>
    <script src="plugin/animated/revealjs-animated.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        controls: true,
        totalTime: 1200,
        hideInactiveCursor: true,
        hideCursorTime: 2000,
        hideAddressBar: true,
        preloadIframes: true,
        progress: false,
        touch: true,
        pdfMaxPagesPerSlide: 1,
        keyboard: {
          67: () => { /* Keycode for the letter 'c' i.e. 'controls' */
            var currentSlide = Reveal.getCurrentSlide();
            var currentVideo = currentSlide.slideBackgroundContentElement.getElementsByTagName("video")[0];
            if (currentVideo) {
              /* Toggle video controls on/off */
              currentVideo.controls = !currentVideo.controls
            }
          },
          32: () => { /* Keycode for spacebar */
            var currentSlide = Reveal.getCurrentSlide();
            var currentVideo = currentSlide.slideBackgroundContentElement.getElementsByTagName("video")[0];
            if (currentVideo) {
              /* Pause/resume video when the spacebar is pressed */
              if (currentVideo.paused == true) currentVideo.play();
              else currentVideo.pause();
            }
            else {
              /* Advance to next slide if no video (default Reveal behaviour) */
              Reveal.next();
            }
          }
        },
        chart: {
          defaults: {
            global: {
              title: { fontColor: "#FFF" },
              legend: {
                position: "bottom",
                labels: { fontColor: "#FFF" },
              },
              tooltips: {
                labels: { fontColor: "#FFF" },
              },
            },
            scale: {
              scaleLabel: { fontColor: "#FFF" },
              gridLines: { color: "#FFF", zeroLineColor: "#FFF" },
              ticks: { fontColor: "#FFF" },
            }
          },
          bar: { backgroundColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)", "rgba(255, 159, 64, .8)","rgba(255, 205, 86, .8)", "rgba(153, 102, 255, .8)" ]},
        },
        menu: {
          themes: true,
          delayInit: true
        },
        pdfSeparateFragments: false,
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMenu, RevealChart ]
      });

      Reveal.addEventListener('hideControls', function() {
        Reveal.configure({controls: false});
        menu_button = document.getElementsByClassName("slide-menu-button")[0];
        if (menu_button) {
          menu_button.style.display = 'none';
        }
      }, false );

      Reveal.addEventListener('slidechanged', function() {
        /* Ensure that the Reveal controls and Menu are available on
         * all slides other than the 'Title-Slide'.
         */
        slide_id = Reveal.getCurrentSlide().getAttribute("id");

        if (slide_id !== "Title-Slide" && slide_id !== "video") {
          config = Reveal.getConfig();
          if (config["controls"] !== true) {
            Reveal.configure({controls: true});
          }

          menu = Reveal.getPlugin("menu");
          if (!menu.isMenuInitialised()) {
            menu.initialiseMenu();
          }
          menu_button = document.getElementsByClassName("slide-menu-button")[0];
          if (menu_button) {
            menu_button.style.display = '';
          }
        }
      }, false );
   </script>
  </body>
</html>
