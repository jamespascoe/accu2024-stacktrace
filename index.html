<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Advanced Usage of the C++23 Stacktrace Library</title>

    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico?">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/league.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/github.css" id="highlight-theme">

  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <section id="Title-Slide"
                 data-state="hideControls"
                 data-menu-title="Title Slide"
                 data-background-image="media/title-slide.png"
                 data-background-size="contain">
        </section>

        <section data-menu-title="Overview">
          <h2>Advanced Usage of the C++23 Stacktrace Library</h2>
            <p>
            <h4>(Stacktraces and How to Use Them)</h4>
            <small>
              Jim (James) Pascoe<br>
              <a href="http://www.james-pascoe.com">http://www.james-pascoe.com</a><br>
              <a href="mailto:james@james-pascoe.com">james@james-pascoe.com</a><p>

              <a href="http://jamespascoe.github.io/accu2024-stacktrace">http://jamespascoe.github.io/accu2024-stacktrace</a>
              <p>
              <font style="color:yellow">ACCU Bristol and Bath Meetup Coordinator</font>
            </small>
          <aside class="notes">
          Hello, good afternoon and welcome - my name is Jim Pascoe and today I am going to talk to you about the C++23 Stacktrace
          library and why its really useful.
          <p>
          Here is my email address and URL (if you want to find out a bit about what I've done in the past) and also, this
          is the link to the online talk, so you can follow along from the comfort of your own browser if you prefer. So,
          you can use the hamburger icon to skip between the slides and select a light theme if you prefer.
          </aside>
        </section>

        <section data-menu-title="Stacktraces">
          <h3 style="color:yellow">Stacktraces, tracebacks, call sequences</h3>
          <ul>
            <span class="fragment"><li>Locate problems without a debugger</li></span>
            <span class="fragment"><ul><li>assertions, exceptions, object lifetimes</li></ul></span>
            <span class="fragment"><li>Introspection</li></span>
            <span class="fragment"><ul><li>performance analysis (KPIs etc.)</span></li></ul></span>
            <span class="fragment"><ul><li>insightful with coroutines</span></li></ul></span>
            <span class="fragment"><li>Signal tracing</span><span class="fragment"> (use with caution)</span></li>
          </ul>
          <aside class="notes">
          </aside>
        </section>

        <section data-menu-title="Approaches">
          <h3 style="color:yellow">C++ Stacktraces</h3>
          <ul>
            <span class="fragment"><li>C++23 gives us standardised stacktraces</li></span>
            <span class="fragment"><ul><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0881r7.html">P0881R7: A Proposal to Add A Stacktrace Library</a></li></ul></span>
            <span class="fragment"><li>Alternatives:</span></li></span>
            <span class="fragment">
              <ul>
                <span class="fragment"><li><a href="https://github.com/jeremy-rifkin/cpptrace">cpptraces</a>: C++11, some signal-safe stack tracing</li></span>
                <span class="fragment"><li><a href="https://github.com/bombela/backward-cpp">backward-cpp</a>: stack trace pretty printing</li></span>
                <span class="fragment"><li><a href="https://www.boost.org/doc/libs/master/doc/html/stacktrace.html">Boost::Stacktrace</a>: mature, some signal-safety</li></span>
              </ul>
            </span>
          </ul>
          <aside class="notes">
          </aside>
        </section>

        <section data-menu-title="Fibonacci Example">
          <h2><a href="https://github.com/jamespascoe/accu2024-example-code/blob/master/stacktrace.cpp">Fibonacci (with stacktrace)</a></h2>
          <pre class="r-stretch"><code class="c++" data-trim data-line-numbers="|15-25|17-22|17|17-22|37-38|40-41|43-49|">
#include &ltiostream&gt
#include &ltformat&gt
#include &ltstacktrace&gt

class fib_with_stacktrace {

  std::stacktrace::size_type max_depth = 0;
  std::stacktrace max_trace;

public:

  fib_with_stacktrace() = default;

  // Return the nth number in the fibonaci sequence
  unsigned int fib(unsigned int n)
  {
    auto trace = std::stacktrace::current();
    auto depth = trace.size();
    if (trace.size() &gt max_depth) {
      max_trace = trace;
      max_depth = depth;
    }

    return n &lt 2 ? n : fib(n-1) + fib(n-2);
  }

  std::stacktrace get_max_trace() const
  {
    return max_trace;
  }
};

int main(void)
{
  fib_with_stacktrace fib_wst;

  for (int i=0; i&lt10; ++i)
    std::cout &lt&lt fib_wst.fib(i) &lt&lt ' ';
  std::cout &lt&lt '\n';

  const std::stacktrace& trace = fib_wst.get_max_trace();
  std::cout &lt&lt "Max stack depth: " &lt&lt trace.size() &lt&lt '\n';

  for (const auto& t : trace)
    std::cout &lt&lt
      std::format (
       "{}:{} {}\n",
       t.source_file(), t.source_line(), t.description()
    );
}
          </code></pre>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h3 style="color:yellow">Compilation and Linking</h3>
          <ul>
            <span class="fragment"><li>GCC build must be enabled with:</li></span>
            <span class="fragment"><ul><li><a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_macros.html">--enable-libstdcxx-backtrace=yes</a></li></ul></span>
            <span class="fragment"><li>'libstdcxx-backtrace' is the implementation:</li></span>
            <span class="fragment"><ul><li><a href="https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=libstdc%2B%2B-v3/include/std/stacktrace;h=92a69a53d986c5da990594e3f35e724b0a16b501;hb=refs/heads/trunk">
              &ltgcc trunk&gt/libstdc++-v3/include/std/stacktrace</a></li></ul></span>
            <span class="fragment"><ul><li><a href="https://gcc.gnu.org/git/?p=gcc.git;a=tree;f=libbacktrace;h=46da9877b26555ae4448a7eb642e7218043cce0a;hb=refs/heads/trunk">
              &ltgcc trunk&gt/libbacktrace</a></li></ul></span>
            <span class="fragment"><li>Compiler options:</li></span>
            <span class="fragment"><ul><li>-g -lstdc++_libbacktrace</li></ul></span>
         </ul>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h2>Fibonacci Output</h2>
          <pre><code data-trim data-line-numbers="|1-2|13-15|12|4-11|3|">
0 1 1 2 3 5 8 13 21 34
Max stack depth was: 13
stacktrace.cpp:17 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:24 fib_with_stacktrace::fib(unsigned int)
stacktrace.cpp:38 main
:0 __libc_start_main (&ltglibc trunk&gt/csu/libc-start.c:129)
:0 _start
:0
          </code></pre>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h3 style="color:yellow">Observations</h3>
          <ul>
            <span class="fragment"><li>Attach information to stack frames via hash support</li></span>
            <span class="fragment"><ul><li><a href="https://en.cppreference.com/w/cpp/utility/stacktrace_entry/hash">std::unordered_map&ltstd::stacktrace_entry, T&gt</a></li></ul></span>
            <span class="fragment"><li>GDB is great for exploring</li></span>
            <span class="fragment"><ul><li>Tip: <a href="https://github.com/cyrus-and/gdb-dashboard">Andrea Cardaci's GDB Dashboard</a></li></ul></span>
            <span class="fragment"><li>Observer for implementation defined native handle</li></span>
            <span class="fragment"><ul><li><a href="https://en.cppreference.com/w/cpp/utility/stacktrace_entry/native_handle">constexpr nh_type native_handle() const noexcept;</a></li></ul></span>
          </ul>
          <aside class="notes">
          </aside>
        </section>

        <section data-menu-title="GDB Dashboard">
          <img class="r-stretch" data-src="media/gdb_dashboard.png" style="background:none; border:none; box-shadow:none;">
        </section>

        <section>
          <h2><a href="https://github.com/jamespascoe/accu2024-example-code/blob/master/coro_http_server.cpp">Coroutine Example</a></h2>
          <pre class="stretch"><code class="c++" style="width:105%" data-trim data-line-numbers="|130-164|89-128|33-87|">
// This is based on the Boost.Beast HTTP coro server example.
// See the following for documentation and details:
//
// https://www.boost.org/doc/libs/1_84_0/libs/beast/doc/html/
// beast/examples.html#beast.examples.servers_advanced

#include &ltboost/asio/dispatch.hpp&gt
#include &ltboost/asio/spawn.hpp&gt
#include &ltboost/asio/strand.hpp&gt
#include &ltboost/beast/core.hpp&gt
#include &ltboost/beast/http.hpp&gt
#include &ltboost/beast/version.hpp&gt
#include &ltboost/config.hpp&gt

#include &ltiostream&gt
#include &ltmemory&gt
#include &ltthread&gt
#include &ltvector&gt
#include &ltstacktrace&gt
#include &ltformat&gt

namespace beast = boost::beast;
namespace http = beast::http;
namespace asio = boost::asio;
using tcp = boost::asio::ip::tcp;

// Report an error
void error(beast::error_code ec, char const* msg)
{
  std::cerr &lt&lt std::format("Error: {} - {}\n", msg, ec.message());
}

  void
do_session(
    beast::tcp_stream& stream,
    asio::yield_context yield)
{
  beast::flat_buffer buffer;
  beast::error_code ec;

  for(;;)
  {
    // Set a timeout (in case the client stops responding)
    stream.expires_after(std::chrono::seconds(30));

    // Read a request
    http::request&lthttp::string_body&gt req;
    http::async_read(stream, buffer, req, yield[ec]);

    if(ec == http::error::end_of_stream) break;

    if(ec) return error(ec, "read request");

    // Handle the request
    auto handle_request = [&req]() -&gt http::message_generator {
      http::response&lthttp::string_body&gt res{
        http::status::ok, req.version()
      };
      res.set(http::field::server, "Beast");
      res.body() = "Hello ACCU 2024!";
      res.prepare_payload();
      res.keep_alive(req.keep_alive());

      for (const auto& t : std::stacktrace::current()) {
        std::string desc = t.description();
        std::cout &lt&lt
          std::format("{}:{}\n  {}()\n",
            t.source_file(), t.source_line(),
            desc.substr(0, desc.find_first_of("(&lt"))
          );
      }

      return res;
    };

    // Send the response
    beast::async_write(stream, handle_request(), yield[ec]);

    if(ec) return error(ec, "write response");

    // Determine if we should close the connection
    if(!req.keep_alive()) break;
  }

  // Close the connection
  stream.socket().shutdown(tcp::socket::shutdown_send, ec);
}

// Accepts incoming connections and launches the sessions
void do_listen(
    asio::io_context& ioc,
    tcp::endpoint endpoint,
    asio::yield_context yield)
{
  beast::error_code ec;

  // Open the acceptor
  tcp::acceptor acceptor(ioc);
  acceptor.open(endpoint.protocol(), ec);
  if(ec) return error(ec, "open");

  // Allow address reuse
  acceptor.set_option(asio::socket_base::reuse_address(true), ec);
  if(ec) return error(ec, "set_option");

  // Bind to the server address
  acceptor.bind(endpoint, ec);
  if(ec) return error(ec, "bind");

  // Start listening for connections
  acceptor.listen(asio::socket_base::max_listen_connections, ec);
  if(ec) return error(ec, "listen");

  for(;;)
  {
    tcp::socket socket(ioc);
    acceptor.async_accept(socket, yield[ec]);
    if(ec)
      error(ec, "accept");
    else
      boost::asio::spawn(
          acceptor.get_executor(),
          std::bind(
            do_session,
            beast::tcp_stream(std::move(socket)),
            std::placeholders::_1));
  }
}

int main(int argc, char *argv[])
{
  if (argc != 4) {
    std::cerr &lt&lt std::format(
        "Usage: {} &ltip-address&gt &ltport&gt &ltnum_threads&gt\n"
        "E.g.: {} 0.0.0.0 8080 2\n",
        argv[0], argv[0]
        );
    return EXIT_FAILURE;
  }

  auto const address = asio::ip::make_address(argv[1]);
  auto const port = static_cast&ltunsigned short&gt(std::atoi(argv[2]));
  auto const num_threads = std::max&ltint&gt(1, std::atoi(argv[3]));

  asio::io_context ioc{num_threads};

  // Spawn a stackful coroutine
  boost::asio::spawn(ioc,
      std::bind(
        &do_listen,
        std::ref(ioc),
        tcp::endpoint{address, port},
        std::placeholders::_1));

  // Run the IO service with the requested number of threads
  std::vector&ltstd::thread&gt v(num_threads-1);
  for (auto i = num_threads - 1; i; --i)
    v.emplace_back([&ioc]{ ioc.run(); });

  // Use the main thread as well
  ioc.run();

  return EXIT_SUCCESS;
}
          </code></pre>
          <aside class="notes">
          Stackful coroutines mean that each coroutine has its own stack. By contrast, C++20
          coroutines are stackless - they suspend execution by returning to the caller and
          the data that is required to resume execution is stored in a callable on the heap
          (so separately from the stack).
          </aside>
        </section>

        <section>
          <h2>Coroutine Output</h2>
          <pre class="r-stretch"><code class="language-plaintext" data-trim data-line-numbers="|2,4,6,8,10,12,14,16,18,20,22|1,3,5,7,9,11,13,15,17,19,21|">
/home/pascoej/accu2024-example-code/coro_http_server.cpp:58
  operator()
/home/pascoej/accu2024-example-code/coro_http_server.cpp:71
  do_session()
/usr/local/include/c++/13.0.1/bits/invoke.h:61
  void std::__invoke_impl()
/usr/local/include/c++/13.0.1/bits/invoke.h:96
  std::__invoke_result()
/usr/local/include/c++/13.0.1/functional:506
  void std::_Bind()
/usr/local/include/c++/13.0.1/functional:591
  void std::_Bind()
/usr/local/include/boost/asio/impl/spawn.hpp:1493
  boost::asio::detail::old_spawn_entry_point()
/usr/local/include/boost/asio/impl/spawn.hpp:1485
  boost::asio::detail::old_spawn_entry_point()
/usr/local/include/boost/asio/impl/spawn.hpp:158
  boost::asio::detail::spawned_coroutine_thread::entry_point()
/usr/local/include/boost/coroutine/detail/pull_coroutine_object.hpp:290
  boost::coroutines::detail::pull_coroutine_object()
/usr/local/include/boost/coroutine/detail/trampoline_pull.hpp:41
  void boost::coroutines::detail::trampoline_pull()
:0
          </code></pre>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h2 style="color:yellow">Asynchronous Signal Safety</h2>
          <ul>
            <span class="fragment"><li>Can I use <a href="https://en.cppreference.com/w/cpp/header/stacktrace">std::stacktrace</a> in a signal handler?</li></span>
            <span class="fragment"><ul><li>Not currently, but the design is extensible</li></ul></span>
            <span class="fragment"><li>Exception </span><span class="fragment">+ signal</span><span class="fragment"> = deadlock</span></li>
            <span class="fragment"><li>Difficult to implement correctly</li>
            <span class="fragment"><ul><li>Collect minimal information in the handler</li></ul></span>
            <span class="fragment"><ul><li>Resolve outside (or in anonther process)</li></ul></span>
          </ul>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h2 style="color:yellow">Conclusions</h2>
          <ul>
            <span class="fragment"><li>Stacktraces are more than tools for debugging logic</li>
              <span class="fragment"><ul><li>Assertions, </span>
              <span class="fragment">introspection, </span>
              <span class="fragment">object lifetimes</li></ul></span>
            <span class="fragment"><li>Stack depth can be a useful proxy</li>
            <span class="fragment"><ul><li>Inexpensive to store - easy to chart</li></ul>
            <span class="fragment"><li>Use with caution in signal handlers</li></span>
            <span class="fragment"><ul><li>See: <a href="https://github.com/jeremy-rifkin/cpptrace">cpptraces</a> and 
              <a href="https://www.boost.org/doc/libs/master/doc/html/stacktrace/reference.html#header.boost.stacktrace.safe_dump_to_hpp">Boost::safe_dump_to</a></li></ul>
            <span class="fragment"><li>Debugging starts in the design phase</li></span>
          </ul>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h2 style="color:yellow">Resources</h2>
          <ul>
            <span class="fragment"><li><a href="https://youtu.be/9IcxniCxKlQ?si=GtuMOVHm8wzRvv56">Episode 336: C++ Weekly (Jason Turner)</a></li></span>
            <span class="fragment"><li><a href="https://www.sandordargo.com/blog/2022/09/21/cpp23-stacktrace-library">Sandor Dargo's Blog</a></li></span>
            <span class="fragment"><li><a href="https://www.boost.org/doc/libs/master/doc/html/stacktrace.html">Boost::Stacktrace Documentation</a></li>
            <span class="fragment"><li>Signal safety:</li>
            <span class="fragment"><ul><li><a href="https://www.boost.org/doc/libs/master/doc/html/stacktrace/theoretical_async_signal_safety.html">Theoretical Async Signal Safety (Boost)</a></li></ul>
            <span class="fragment"><ul><li><a href="https://github.com/jeremy-rifkin/cpptrace?tab=readme-ov-file#signal-safe-tracing">Signal-Safe Tracing (cpptrace)</a></li></ul>
            <span class="fragment"><ul><li><a href="https://man7.org/linux/man-pages/man7/signal-safety.7.html">signal-safety (Linux man page)</a></li></ul>
          </ul>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h2>Questions?</h2>
          <p><p>
          <a href="http://www.james-pascoe.com">http://www.james-pascoe.com</a><br>
          <a href="mailto:james@james-pascoe.com">james@james-pascoe.com</a><p>

          <a href="http://jamespascoe.github.io/accu2024-stacktrace">http://jamespascoe.github.io/accu2024-stacktrace</a>
          <p>
          <font style="color:yellow">ACCU Bristol and Bath Meetup Coordinator</font>
        </section>

        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/menu/menu.js"></script>
    <script src="plugin/chart/Chart.min.js"></script>
    <script src="plugin/chart/plugin.js"></script>
    <script src="plugin/animated/revealjs-animated.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        controls: true,
        totalTime: 1200,
        hideInactiveCursor: true,
        hideCursorTime: 2000,
        hideAddressBar: true,
        preloadIframes: true,
        progress: false,
        touch: true,
        pdfMaxPagesPerSlide: 1,
        keyboard: {
          67: () => { /* Keycode for the letter 'c' i.e. 'controls' */
            var currentSlide = Reveal.getCurrentSlide();
            var currentVideo = currentSlide.slideBackgroundContentElement.getElementsByTagName("video")[0];
            if (currentVideo) {
              /* Toggle video controls on/off */
              currentVideo.controls = !currentVideo.controls
            }
          },
          32: () => { /* Keycode for spacebar */
            var currentSlide = Reveal.getCurrentSlide();
            var currentVideo = currentSlide.slideBackgroundContentElement.getElementsByTagName("video")[0];
            if (currentVideo) {
              /* Pause/resume video when the spacebar is pressed */
              if (currentVideo.paused == true) currentVideo.play();
              else currentVideo.pause();
            }
            else {
              /* Advance to next slide if no video (default Reveal behaviour) */
              Reveal.next();
            }
          }
        },
        chart: {
          defaults: {
            global: {
              title: { fontColor: "#FFF" },
              legend: {
                position: "bottom",
                labels: { fontColor: "#FFF" },
              },
              tooltips: {
                labels: { fontColor: "#FFF" },
              },
            },
            scale: {
              scaleLabel: { fontColor: "#FFF" },
              gridLines: { color: "#FFF", zeroLineColor: "#FFF" },
              ticks: { fontColor: "#FFF" },
            }
          },
          bar: { backgroundColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)", "rgba(255, 159, 64, .8)","rgba(255, 205, 86, .8)", "rgba(153, 102, 255, .8)" ]},
        },
        menu: {
          themes: true,
          delayInit: true
        },
        pdfSeparateFragments: false,
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMenu, RevealChart ]
      });

      Reveal.addEventListener('hideControls', function() {
        Reveal.configure({controls: false});
        menu_button = document.getElementsByClassName("slide-menu-button")[0];
        if (menu_button) {
          menu_button.style.display = 'none';
        }
      }, false );

      Reveal.addEventListener('slidechanged', function() {
        /* Ensure that the Reveal controls and Menu are available on
         * all slides other than the 'Title-Slide'.
         */
        slide_id = Reveal.getCurrentSlide().getAttribute("id");

        if (slide_id !== "Title-Slide" && slide_id !== "video") {
          config = Reveal.getConfig();
          if (config["controls"] !== true) {
            Reveal.configure({controls: true});
          }

          menu = Reveal.getPlugin("menu");
          if (!menu.isMenuInitialised()) {
            menu.initialiseMenu();
          }
          menu_button = document.getElementsByClassName("slide-menu-button")[0];
          if (menu_button) {
            menu_button.style.display = '';
          }
        }
      }, false );
   </script>
  </body>
</html>
